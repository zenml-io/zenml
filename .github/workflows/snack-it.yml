name: Snack-it - Create Issue from PR

# This workflow creates a "snack" issue when a PR is labeled with "snack-it"
# Uses Claude AI to generate a concise, actionable issue description from the PR
# The issue inherits all PR labels, gets tagged with "snack", and is added to the ZenML Roadmap project
# The PR branch is linked to the issue for easy tracking
#
# Can also be triggered manually via workflow_dispatch with a PR number for testing
# 
# REQUIREMENTS:
# - ANTHROPIC_API_KEY: Anthropic API key for Claude AI
# - GH_PAT_TOKEN_FOR_SNACK_IT: Personal Access Token with repo, project, and org:read scopes
#   (needed for adding issues to organization projects)

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, unlabeled]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to create snack issue from'
        required: true
        type: number

permissions:
  issues: write
  pull-requests: write
  contents: read
  id-token: write

jobs:
  create-snack-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Check if snack-it label is present
        id: check-label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let hasSnackItLabel = false;
            
            if (context.eventName === 'workflow_dispatch') {
              // Manual trigger - always proceed
              hasSnackItLabel = true;
              console.log('Manual trigger detected, will create issue for PR #' + context.payload.inputs.pr_number);
            } else if (context.payload.pull_request) {
              // Check if PR has snack-it label
              const labels = context.payload.pull_request.labels || [];
              hasSnackItLabel = labels.some(label => label.name === 'snack-it');
              
              console.log('PR labels:', labels.map(l => l.name).join(', '));
              console.log('Has snack-it label:', hasSnackItLabel);
              console.log('Event action:', context.payload.action);
              
              if (context.payload.label) {
                console.log('Label from event:', context.payload.label.name);
              }
            }
            
            core.setOutput('snack_it', hasSnackItLabel ? 'true' : 'false');
            
            if (hasSnackItLabel) {
              console.log('‚úÖ Will create snack issue');
            } else {
              console.log('‚è≠Ô∏è  Skipping - no snack-it label');
            }

      - name: Checkout repository
        if: steps.check-label.outputs.snack_it == 'true'
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Generate issue content with Claude
        if: steps.check-label.outputs.snack_it == 'true'
        id: claude-generate
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          track_progress: false
          prompt: |
            Generate a snack issue from PR #${{ github.event_name == 'workflow_dispatch' && inputs.pr_number || github.event.pull_request.number }}.
            
            A "snack" is a small, bite-sized task that can be completed relatively quickly.
            
            Steps:
            1. Run: gh pr view ${{ github.event_name == 'workflow_dispatch' && inputs.pr_number || github.event.pull_request.number }} --json title,body,author,headRefName,files
            2. Run: gh pr diff ${{ github.event_name == 'workflow_dispatch' && inputs.pr_number || github.event.pull_request.number }} (if needed for context)
            3. Analyze what was accomplished in this PR
            4. Output exactly in this format (no code blocks, no extra text):
            
            ISSUE_TITLE:
            A concise, actionable title (max 80 chars)
            
            ISSUE_BODY:
            A brief summary (2-3 sentences) explaining what this snack accomplishes.
            
            Key changes:
            - Change 1
            - Change 2
            - etc.
            
            References PR #${{ github.event_name == 'workflow_dispatch' && inputs.pr_number || github.event.pull_request.number }}
            
            CRITICAL: Output ONLY the above format. No markdown code blocks. No commentary before or after.
          claude_args: --allowed-tools "Bash(gh pr view:*),Bash(gh pr diff:*)"

      - name: Parse Claude output and create issue
        if: steps.check-label.outputs.snack_it == 'true'
        id: create-issue
        uses: actions/github-script@v7
        env:
          CLAUDE_OUTPUT: ${{ steps.claude-generate.outputs.result }}
          PR_NUMBER: ${{ github.event_name == 'workflow_dispatch' && inputs.pr_number || github.event.pull_request.number }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Get PR details (handle both workflow_dispatch and pull_request events)
            let pr;
            if (context.eventName === 'workflow_dispatch') {
              const prNumber = parseInt(process.env.PR_NUMBER);
              const prData = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              pr = prData.data;
            } else {
              pr = context.payload.pull_request;
            }
            const claudeOutput = process.env.CLAUDE_OUTPUT || '';
            
            // Parse Claude's output
            let issueTitle = pr.title;  // Fallback to PR title
            let issueBody = `This issue tracks the work completed in PR #${pr.number}.\n\n${pr.body || 'No description provided.'}`;  // Fallback
            let usedClaude = false;
            
            if (claudeOutput && claudeOutput.trim()) {
              console.log('Claude output received:', claudeOutput.substring(0, 200) + '...');
              
              // Extract title - more flexible regex
              const titleMatch = claudeOutput.match(/ISSUE_TITLE:\s*\n+(.+?)(?=\n+ISSUE_BODY:)/s);
              if (titleMatch && titleMatch[1].trim()) {
                issueTitle = titleMatch[1].trim();
                console.log('Extracted title:', issueTitle);
              } else {
                console.log('‚ö†Ô∏è  Failed to extract title from Claude output, using PR title');
              }
              
              // Extract body - more flexible regex
              const bodyMatch = claudeOutput.match(/ISSUE_BODY:\s*\n+([\s\S]+?)$/);
              if (bodyMatch && bodyMatch[1].trim()) {
                issueBody = bodyMatch[1].trim();
                console.log('Extracted body length:', issueBody.length, 'chars');
                usedClaude = true;
              } else {
                console.log('‚ö†Ô∏è  Failed to extract body from Claude output, using PR body');
              }
            } else {
              console.log('‚ö†Ô∏è  No Claude output received, using PR title and body as fallback');
            }
            
            // Add footer with metadata
            if (usedClaude) {
              issueBody += `\n\n---\n_ü§ñ This snack issue was automatically created from PR #${pr.number} using Claude AI._`;
            } else {
              issueBody += `\n\n---\n_ü§ñ This snack issue was automatically created from PR #${pr.number}._`;
            }
            
            console.log('Creating issue with title:', issueTitle);
            console.log('AI-generated:', usedClaude);
            
            // Create the issue
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: ['snack']
            });
            
            console.log(`‚úÖ Created issue #${issue.data.number}`);
            
            // Get all labels from the PR
            const prLabels = pr.labels.map(label => label.name);
            
            // Add all PR labels to the issue (excluding 'snack-it' which triggered this)
            const labelsToAdd = prLabels.filter(label => label !== 'snack-it');
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.data.number,
                labels: labelsToAdd
              });
              console.log(`Added labels: ${labelsToAdd.join(', ')}`);
            }
            
            // Store issue data for next step and PR comment
            core.setOutput('issue_number', issue.data.number);
            core.setOutput('issue_node_id', issue.data.node_id);
            core.setOutput('pr_number', pr.number);
            
            console.log(`‚úÖ Created issue #${issue.data.number}`);
            return issue.data.number;

      - name: Add issue to project and set status
        if: steps.check-label.outputs.snack_it == 'true'
        continue-on-error: true
        id: add-to-project
        uses: actions/github-script@v7
        env:
          ISSUE_NUMBER: ${{ steps.create-issue.outputs.issue_number }}
          ISSUE_NODE_ID: ${{ steps.create-issue.outputs.issue_node_id }}
          PR_NUMBER: ${{ steps.create-issue.outputs.pr_number }}
        with:
          github-token: ${{ secrets.GH_PAT_TOKEN_FOR_SNACK_IT }}
          script: |
            // Use the issue created in the previous step (avoid race condition)
            const issueNumber = parseInt(process.env.ISSUE_NUMBER);
            const issueNodeId = process.env.ISSUE_NODE_ID;
            const prNumber = parseInt(process.env.PR_NUMBER);
            
            console.log(`Working with issue #${issueNumber}`);
            
            // Get full issue and PR details for later use
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            try {
              // GraphQL query to add item to project
              // Project number from URL: https://github.com/orgs/zenml-io/projects/1
              const projectNumber = 1;
              const orgName = 'zenml-io';
              
              // First, get the project ID
              const projectQuery = `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    fields(first: 20) {
                      nodes {
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          options {
                            id
                            name
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;
            
            const projectData = await github.graphql(projectQuery, {
              org: orgName,
              number: projectNumber
            });
            
            const project = projectData.organization.projectV2;
            console.log(`Found project ID: ${project.id}`);
            
            // Find the Status field and "In Review" option
            const statusField = project.fields.nodes.find(field => field.name === 'Status');
            if (!statusField) {
              console.log('Status field not found in project');
              console.log('Available fields:', project.fields.nodes.map(f => f.name));
            }
            
            const inReviewOption = statusField?.options.find(opt => 
              opt.name === 'In Review' || opt.name === 'In review'
            );
            
            if (!inReviewOption) {
              console.log('In Review option not found');
              console.log('Available options:', statusField?.options.map(o => o.name));
            }
            
            // Add the issue to the project
            const addToProjectMutation = `
              mutation($projectId: ID!, $contentId: ID!) {
                addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                  item {
                    id
                  }
                }
              }
            `;
            
            const addResult = await github.graphql(addToProjectMutation, {
              projectId: project.id,
              contentId: issueNodeId
            });
            
            const itemId = addResult.addProjectV2ItemById.item.id;
            console.log(`Added issue #${issueNumber} to project with item ID: ${itemId}`);
            
            // Update the status to "In Review" if we found the field and option
            if (statusField && inReviewOption) {
              const updateStatusMutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(
                    input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { singleSelectOptionId: $optionId }
                    }
                  ) {
                    projectV2Item {
                      id
                    }
                  }
                }
              `;
              
              await github.graphql(updateStatusMutation, {
                projectId: project.id,
                itemId: itemId,
                fieldId: statusField.id,
                optionId: inReviewOption.id
              });
              
              console.log(`Set status to "In Review"`);
              } else {
                console.log(`Note: Could not set status automatically. Please set manually in the project.`);
              }
              
              // Link the PR branch to the issue
              const prBranch = pr.data.head.ref;
              const prRepo = pr.data.head.repo.full_name;
              
              console.log(`Linking branch ${prBranch} to issue #${issueNumber}`);
              
              try {
                // Create a development link between the issue and the branch
                const linkBranchMutation = `
                  mutation($issueId: ID!, $repositoryId: ID!, $branch: String!) {
                    createLinkedBranch(input: {
                      issueId: $issueId
                      repositoryId: $repositoryId
                      name: $branch
                    }) {
                      linkedBranch {
                        id
                      }
                    }
                  }
                `;
                
                // Get repository ID
                const repoData = await github.rest.repos.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                
                await github.graphql(linkBranchMutation, {
                  issueId: issueNodeId,
                  repositoryId: repoData.data.node_id,
                  branch: prBranch
                });
                
                console.log(`‚úÖ Linked branch ${prBranch} to issue #${issueNumber}`);
              } catch (branchError) {
                console.log(`Note: Could not link branch automatically: ${branchError.message}`);
                console.log(`Branch can be linked manually in the issue sidebar.`);
              }
              
              console.log(`‚úÖ Successfully added issue #${issueNumber} to ZenML Roadmap project`);
              core.setOutput('project_added', 'true');
              
            } catch (error) {
              console.error(`‚ùå Error adding issue to project: ${error.message}`);
              console.error(`This might be due to insufficient permissions on the GitHub token.`);
              console.error(`Please ensure GH_PAT_TOKEN_FOR_SNACK_IT secret has 'project' and 'org:read' scopes.`);
              console.error(`You can manually add issue #${issueNumber} to the project at:`);
              console.error(`https://github.com/orgs/zenml-io/projects/1`);
              
              core.setOutput('project_added', 'false');
              
              // Don't fail the workflow, just log the error
              // The issue was still created successfully
            }

      - name: Comment on PR
        if: steps.check-label.outputs.snack_it == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = '${{ steps.create-issue.outputs.issue_number }}';
            const prNumber = '${{ steps.create-issue.outputs.pr_number }}';
            const projectAdded = '${{ steps.add-to-project.outputs.project_added }}' === 'true';
            
            let message = `üçø Snack issue created: #${issueNumber}\n\n`;
            
            if (projectAdded) {
              message += `This issue has been added to the [ZenML Roadmap](https://github.com/orgs/zenml-io/projects/1) project and set to "In Review".\n\n`;
            } else {
              message += `‚ö†Ô∏è The issue could not be automatically added to the project board. Please add it manually to the [ZenML Roadmap](https://github.com/orgs/zenml-io/projects/1).\n\n`;
            }
            
            message += `_Generated with Claude AI ‚ú®_`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(prNumber),
              body: message
            });
            
            console.log(`Commented on PR #${prNumber}`);

