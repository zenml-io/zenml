"""tags table [6119cd9b93c2].

Revision ID: 6119cd9b93c2
Revises: 0.46.1
Create Date: 2023-11-08 11:52:16.440417

"""

import json
import random
from collections import defaultdict
from datetime import datetime
from uuid import uuid4

import sqlalchemy as sa
import sqlmodel
from alembic import op

# revision identifiers, used by Alembic.
revision = "6119cd9b93c2"
down_revision = "0.46.1"
branch_labels = None
depends_on = None


def upgrade() -> None:
    """Upgrade database schema and/or data, creating a new revision."""
    # ### commands auto generated by Alembic - please adjust! ###
    from zenml.enums import ColorVariants, TaggableResourceTypes

    bind = op.get_bind()
    session = sqlmodel.Session(bind=bind)

    op.create_table(
        "tag",
        sa.Column("color", sa.VARCHAR(length=255), nullable=False),
        sa.Column("id", sqlmodel.sql.sqltypes.GUID(), nullable=False),
        sa.Column("created", sa.DateTime(), nullable=False),
        sa.Column("updated", sa.DateTime(), nullable=False),
        sa.Column("name", sqlmodel.sql.sqltypes.AutoString(), nullable=False),
        sa.PrimaryKeyConstraint("id"),
    )

    # fetch current tags in Model table
    model_tags = session.execute(
        sa.text(
            """
            SELECT id, tags
            FROM model
            WHERE tags IS NOT NULL
            """
        )
    )
    # find unique tags and de-json tags
    unique_tags: set[str] = set()
    model_tags_prepared = []
    for id_, tags in model_tags:
        try:
            model_tags_prepared.append((id_, set(json.loads(tags))))
            unique_tags = unique_tags.union(model_tags_prepared[-1][1])
        except json.JSONDecodeError:
            continue
    # if some tags exist insert it into new Tag table
    if unique_tags:
        insert_tags = """
        INSERT INTO tag
        (id, name, color, created, updated)
        VALUES 
        """
        now = str(datetime.now())
        for tag in unique_tags:
            insert_tags += f"('{uuid4().hex}', '{tag}', '{random.choice(list(ColorVariants)).value}', '{now}', '{now}'),"
        insert_tags = insert_tags[:-1] + ";"
        session.execute(sa.text(insert_tags))

    op.create_table(
        "tag_resource",
        sa.Column("tag_id", sqlmodel.sql.sqltypes.GUID(), nullable=False),
        sa.Column("resource_id", sqlmodel.sql.sqltypes.GUID(), nullable=False),
        sa.Column("resource_type", sa.VARCHAR(length=255), nullable=False),
        sa.Column("id", sqlmodel.sql.sqltypes.GUID(), nullable=False),
        sa.Column("created", sa.DateTime(), nullable=False),
        sa.Column("updated", sa.DateTime(), nullable=False),
        sa.ForeignKeyConstraint(
            ["tag_id"],
            ["tag.id"],
            name="fk_tag_resource_tag_id_tag",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id"),
    )

    # if some tags exist insert relation to Models in new table
    if unique_tags:
        tags_with_ids = session.execute(sa.text("SELECT id, name FROM tag"))
        tags_ids_mapping = {}
        for id_, name in tags_with_ids:
            tags_ids_mapping[name] = id_

        insert_tag_models = """
        INSERT INTO tag_resource
        (id, tag_id, resource_id, resource_type, created, updated)
        VALUES 
        """
        now = str(datetime.now())
        for model_id_, tags_in_model in model_tags_prepared:
            for tag in tags_in_model:
                insert_tag_models += (
                    f"('{uuid4().hex}', "
                    f"'{tags_ids_mapping[tag]}', '{model_id_}', "
                    f"'{TaggableResourceTypes.MODEL.value}', '{now}', '{now}'),"
                )
        insert_tag_models = insert_tag_models[:-1] + ";"
        session.execute(sa.text(insert_tag_models))

    session.commit()

    with op.batch_alter_table("model", schema=None) as batch_op:
        batch_op.drop_column("tags")

    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade database schema and/or data back to the previous revision."""
    # ### commands auto generated by Alembic - please adjust! ###
    bind = op.get_bind()
    session = sqlmodel.Session(bind=bind)

    with op.batch_alter_table("model", schema=None) as batch_op:
        batch_op.add_column(sa.Column("tags", sa.TEXT(), nullable=True))

    # fetch model-tag pairs
    model_tags = session.execute(
        sa.text(
            """
            SELECT resource_id,t.name
            FROM tag_resource as tr
            JOIN tag as t ON tr.tag_id = t.id
            """
        )
    )
    # aggregate by model_id
    model_tags_combined = defaultdict(set)
    for model_id_, tag_ in model_tags:
        model_tags_combined[model_id_].add(tag_)
    update_query = sa.text(
        """
        UPDATE model
        SET tags = :tags
        WHERE id = :model_id
        """
    )
    # push them as string lists to Model table
    for model_id_, tags_ in model_tags_combined.items():
        session.execute(
            update_query,
            params=dict(tags=json.dumps(list(tags_)), model_id=model_id_),
        )
    session.commit()

    op.drop_table("tag_resource")
    op.drop_table("tag")
    # ### end Alembic commands ###
