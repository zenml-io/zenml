#  Copyright (c) ZenML GmbH 2020. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at:
#
#       https://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
#  or implied. See the License for the specific language governing
#  permissions and limitations under the License.
"""Logger implementation."""

import json
import logging
import os
import sys
from contextvars import ContextVar
from typing import Any, Dict, Optional

from rich.traceback import install as rich_tb_install

from zenml.constants import (
    ENABLE_RICH_TRACEBACK,
    ENV_ZENML_LOGGING_COLORS_DISABLED,
    ENV_ZENML_SUPPRESS_LOGS,
    ZENML_LOGGING_VERBOSITY,
    handle_bool_env_var,
)
from zenml.enums import LoggingLevels

ZENML_LOGGING_COLORS_DISABLED = handle_bool_env_var(
    ENV_ZENML_LOGGING_COLORS_DISABLED, False
)


# Logic for formatting console messages
step_names_in_console: ContextVar[bool] = ContextVar(
    "step_names_in_console", default=False
)

grey: str = "\x1b[90m"
white: str = "\x1b[37m"
pink: str = "\x1b[35m"
green: str = "\x1b[32m"
yellow: str = "\x1b[33m"
red: str = "\x1b[31m"
cyan: str = "\x1b[1;36m"
bold_red: str = "\x1b[31;1m"
purple: str = "\x1b[38;5;105m"
blue: str = "\x1b[34m"
reset: str = "\x1b[0m"

COLORS: Dict[LoggingLevels, str] = {
    LoggingLevels.DEBUG: grey,
    LoggingLevels.INFO: white,
    LoggingLevels.WARN: yellow,
    LoggingLevels.ERROR: red,
    LoggingLevels.CRITICAL: bold_red,
}

_original_stdout_write: Optional[Any] = None
_original_stderr_write: Optional[Any] = None
_stdout_wrapped: bool = False
_stderr_wrapped: bool = False


def _add_step_name_to_message(message: str) -> str:
    """Adds the step name to the message.

    Args:
        message: The message to add the step name to.

    Returns:
        The message with the step name added.
    """
    try:
        if step_names_in_console.get():
            from zenml.steps import get_step_context

            step_context = get_step_context()

            if step_context and message not in ["\n", ""]:
                # For progress bar updates (with \r), inject the step name after the \r
                if "\r" in message:
                    message = message.replace(
                        "\r", f"\r[{step_context.step_name}] "
                    )
                else:
                    message = f"[{step_context.step_name}] {message}"
    except Exception:
        # If we can't get step context, just use the original message
        pass

    return message


def format_console_message(message: str) -> str:
    """Format a message for console output.

    Args:
        message: The message to format.

    Returns:
        The formatted message.
    """
    return message


# Logger utilities
def get_logger(logger_name: str) -> logging.Logger:
    """Main function to get logger name,.

    Args:
        logger_name: Name of logger to initialize.

    Returns:
        A logger object.
    """
    return logging.getLogger(logger_name)


def get_logging_level() -> LoggingLevels:
    """Get logging level from the env variable.

    Returns:
        The logging level.

    Raises:
        KeyError: If the logging level is not found.
    """
    verbosity = ZENML_LOGGING_VERBOSITY.upper()
    if verbosity not in LoggingLevels.__members__:
        raise KeyError(
            f"Verbosity must be one of {list(LoggingLevels.__members__.keys())}"
        )
    return LoggingLevels[verbosity]


def set_root_verbosity() -> None:
    """Set the root verbosity."""
    level = get_logging_level()
    if level != LoggingLevels.NOTSET:
        if ENABLE_RICH_TRACEBACK:
            rich_tb_install(show_locals=(level == LoggingLevels.DEBUG))

        logging.root.setLevel(level=level.value)
        get_logger(__name__).debug(
            f"Logging set to level: {logging.getLevelName(level.value)}"
        )
    else:
        logging.disable(sys.maxsize)
        logging.getLogger().disabled = True
        get_logger(__name__).debug("Logging NOTSET")


class ZenMLFormatter(logging.Formatter):
    """Formats logs according to custom specifications."""

    def format(self, record: logging.LogRecord) -> str:
        """Converts a log record to a (colored) string or structured JSON.

        Args:
            record: LogRecord generated by the code.

        Returns:
            A string formatted according to specifications.
        """
        data = {
            "zenml": True,
            "timestamp": self.formatTime(record, datefmt="%Y-%m-%dT%H:%M:%S"),
            "level": record.levelname,
            "name": record.name,
            "message": record.getMessage(),
        }

        if record.exc_info:
            data["exc_info"] = self.formatException(record.exc_info)

        return json.dumps(data, ensure_ascii=False)


def _wrapped_write(original_write: Any, stream_name: str) -> Any:
    """Wrap stdout/stderr write method to parse and route logs."""
    from zenml.logging.step_logging import get_active_log_store, LogEntry
    from zenml.utils import utc_now

    def wrapped_write(text: str) -> int:
        """Wrap the write method to parse and route logs."""
        message = text
        name = None
        level = (
            LoggingLevels.INFO
            if stream_name == "info"
            else LoggingLevels.ERROR
        )
        timestamp = utc_now()

        # Try to extract the message from a potential JSONified log entry
        if text.startswith("{") and text.endswith("}"):
            try:
                data = json.loads(text)

                if "zenml" in data and "message" in data:
                    message = data["message"]
                    name = data.get("name", None)
                    level = data.get("level", level)
                    timestamp = data.get("timestamp", timestamp)
                else:
                    message = data

            except Exception:
                message = text

        # If there is an active log store
        if log_store := get_active_log_store():
            log_store.emit(
                LogEntry(
                    message=message,
                    name=name,
                    level=level,
                    timestamp=timestamp,
                )
            )

        # Format the message for console output
        message = format_console_message(message)

        return original_write(message)

    return wrapped_write


def wrap_stdout_stderr() -> None:
    """Wrap stdout and stderr write methods."""
    global _stdout_wrapped, _stderr_wrapped
    global _original_stdout_write, _original_stderr_write

    if not _stdout_wrapped:
        _original_stdout_write = getattr(sys.stdout, "write")
        setattr(
            sys.stdout,
            "write",
            _wrapped_write(_original_stdout_write, "info"),
        )
        _stdout_wrapped = True

    if not _stderr_wrapped:
        _original_stderr_write = getattr(sys.stderr, "write")
        setattr(
            sys.stderr,
            "write",
            _wrapped_write(_original_stderr_write, "error"),
        )
        _stderr_wrapped = True


def get_zenml_handler() -> Any:
    """Get console handler for logging.

    Returns:
        A console handler.
    """
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(ZenMLFormatter())
    return handler


def init_logging() -> None:
    """Initialize the logging system."""
    set_root_verbosity()
    wrap_stdout_stderr()

    # Add the ZenML handler to the root logger
    root_logger = logging.getLogger()
    root_logger.addHandler(get_zenml_handler())

    # Mute tensorflow cuda warnings
    os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"

    # Enable logs if environment variable SUPPRESS_ZENML_LOGS is not set to True
    suppress_zenml_logs: bool = handle_bool_env_var(
        ENV_ZENML_SUPPRESS_LOGS, True
    )
    if suppress_zenml_logs:
        # suppress logger info messages
        suppressed_logger_names = [
            "urllib3",
            "azure.core.pipeline.policies.http_logging_policy",
            "grpc",
            "requests",
            "kfp",
            "tensorflow",
        ]
        for logger_name in suppressed_logger_names:
            logging.getLogger(logger_name).setLevel(logging.WARNING)

        # disable logger messages
        disabled_logger_names = [
            "rdbms_metadata_access_object",
            "backoff",
            "segment",
        ]
        for logger_name in disabled_logger_names:
            logging.getLogger(logger_name).setLevel(logging.WARNING)
            logging.getLogger(logger_name).disabled = True
